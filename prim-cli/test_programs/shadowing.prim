// Comprehensive test of variable shadowing
// Shadowing rules should match Rust:
// - Shadowing within a block does not permanently shadow outer variables
// - Shadowing can change mutability
// - Each shadow creates a new variable

import std.io.println_i32

fn test_basic_shadow() -> i32 {
    let x = 1
    let x = 2
    x
}

fn test_block_shadow() -> i32 {
    let x = 10
    {
        let x = 20
        // x is 20 here, but doesn't affect outer x
    }
    x  // should be 10
}

fn test_nested_blocks() -> i32 {
    let x = 100
    {
        let x = 200
        {
            let x = 300
            // x is 300 here
        }
        // x is 200 here
    }
    x  // should be 100
}

fn test_shadow_in_if() -> i32 {
    let x = 1
    if true {
        let x = 2
        // x is 2 here
    }
    x  // should be 1
}

fn test_shadow_in_if_else() -> i32 {
    let x = 1
    if false {
        let x = 2
    } else {
        let x = 3
    }
    x  // should be 1
}

fn test_mutability_change() -> i32 {
    let x = 5
    let mut x = x + 1  // shadow with mutable version
    x = x + 1
    x  // should be 7
}

fn test_shadow_uses_outer() -> i32 {
    let x = 10
    let x = x + 5  // new x based on old x
    x  // should be 15
}

fn test_block_shadow_uses_outer() -> i32 {
    let x = 100
    {
        let x = x + 50  // inner x based on outer x
        // x is 150 here
    }
    x  // should still be 100
}

fn main() {
    println_i32(test_basic_shadow())       // 2
    println_i32(test_block_shadow())       // 10
    println_i32(test_nested_blocks())      // 100
    println_i32(test_shadow_in_if())       // 1
    println_i32(test_shadow_in_if_else())  // 1
    println_i32(test_mutability_change())  // 7
    println_i32(test_shadow_uses_outer())  // 15
    println_i32(test_block_shadow_uses_outer())  // 100
}
